**شاخه (Branch) در Git دقیقاً چیست؟**  

### ۱. تعریف ساده و مفهومی (برای درک اولیه)
در Git، **برنچ (Branch) یا شاخه** یک **خط توسعه موازی و مستقل** از کد پروژه‌ته.  
تصور کن پروژه‌ت مثل یک جاده اصلی (معمولاً به اسم `main` یا قبلاً `master`) هست. وقتی می‌خوای یه ویژگی جدید اضافه کنی یا یه باگ رو فیکس کنی، به جای اینکه مستقیم روی جاده اصلی کار کنی (که ممکنه کد رو خراب کنه)، یه **جاده فرعی** می‌سازی، روی اون جاده کار می‌کنی، تست می‌کنی، و وقتی آماده شد، جاده فرعی رو به جاده اصلی وصل می‌کنی (Merge).

مزیتش اینه:
- کارهایت کاملاً ایزوله (جدا) می‌مونه.
- چند نفر می‌تونن همزمان روی فیچرهای مختلف کار کنن بدون اینکه به همدیگه گیر بدن.
- اگه کار خراب شد، فقط همون برنچ رو حذف می‌کنی، کد اصلی سالم می‌مونه.

### ۲. تعریف فنی دقیق (دقیقاً چی داخل Git ذخیره می‌شه؟)
اینجا جاییه که خیلی‌ها اشتباه می‌کنن!

**برنچ در Git فقط یک اشاره‌گر (pointer) سبک‌وزن به یک commit خاص است.**  
نه کپی کامل پروژه، نه فولدر جدید، نه هیچ چیز سنگین.

- هر برنچ در واقع یک **فایل متنی خیلی کوچیک** (حدود ۴۱ بایت) داخل پوشهٔ مخزنته:
  ```
  .git/refs/heads/اسم-برنچ
  ```
  داخل این فایل فقط یک خط هست: هش SHA-1 آخرین commit اون برنچ.

مثال واقعی:
```
$ cat .git/refs/heads/main
a1b2c3d4e5f6... (هش کامیت آخر)
```

به همین دلیل:
- ایجاد برنچ تقریباً **آنی** (۰ ثانیه) است.
- می‌تونی صدها یا هزاران برنچ داشته باشی بدون اینکه فضای دیسک پر بشه.
- Git داده‌ها رو به صورت **snapshot** (عکس لحظه‌ای کامل از پروژه) ذخیره می‌کنه، نه تغییرات (delta). هر commit یک snapshot کامل داره.

### ۳. HEAD چیست؟ (مهم‌ترین مفهوم)
Git همیشه یک اشاره‌گر ویژه به اسم **HEAD** داره که نشون می‌ده «الان روی کدوم commit یا برنچ کار می‌کنی».

- وقتی روی برنچ `main` هستی → `HEAD` به `main` اشاره می‌کنه.
- وقتی commit می‌زنی → commit جدید ساخته می‌شه و برنچی که HEAD بهش اشاره داره، جلو می‌ره.

### ۴. چطور کار می‌کنه؟ (با مثال تصویری)

فرض کن تاریخچه اولیه پروژه این شکلیه:

```
A ── B ── C   ← main (و HEAD هم اینجا هست)
```

حالا برنچ جدید می‌سازی:
```bash
git switch -c feature/login   # یا git checkout -b feature/login
```

حالا این می‌شه:

```
          feature/login (HEAD)
               ↓
A ── B ── C
          ↑
        main
```

دو تا commit جدید روی feature/login می‌زنی:

```
          feature/login (HEAD)
               ↓
A ── B ── C ── D ── E
          ↑
        main
```

حالا برمی‌گردی به main:

```bash
git switch main
```

و دو commit دیگه می‌زنی:

```
          feature/login
               ↓
A ── B ── C ── D ── E
          ↑
        main ── F ── G   (HEAD)
```

تاریخچه **انشعاب** (divergent) پیدا کرده.







(تصاویر بالا مدل‌های واقعی Git Flow و GitHub Flow رو نشون می‌دن)

### ۵. دستورات اصلی (به‌روز ۲۰۲۶)

| کار | دستور جدید (توصیه‌شده) | دستور قدیمی |
|------|-------------------------|-------------|
| لیست برنچ‌ها | `git branch` یا `git branch -a` | همان |
| ایجاد + سوئیچ | `git switch -c feature/xxx` | `git checkout -b feature/xxx` |
| فقط ایجاد | `git branch feature/xxx` | همان |
| سوئیچ | `git switch main` | `git checkout main` |
| ادغام (Merge) | `git switch main`<br>`git merge feature/xxx` | همان |
| Rebase (تمیز کردن تاریخچه) | `git switch feature/xxx`<br>`git rebase main` | همان |
| حذف برنچ (امن) | `git branch -d feature/xxx` | همان |
| حذف اجباری | `git branch -D feature/xxx` | همان |
| نمایش گرافیکی تاریخچه | `git log --oneline --graph --decorate --all` | همان |

### ۶. برنچ‌های ریموت (Remote Branches)
وقتی `git push origin feature/login` می‌زنی، Git یک برنچ محلی tracking به اسم `origin/feature/login` می‌سازه.  
این برنچ‌ها داخل `.git/refs/remotes/origin/` ذخیره می‌شن.

دستورات مهم:
- `git fetch` → آپدیت کردن اطلاعات برنچ‌های ریموت
- `git pull` = fetch + merge
- `git push -u origin feature/xxx` → push + تنظیم upstream (برای دفعه‌های بعد فقط `git push` کافیه)

### ۷. بهترین شیوه‌ها (Best Practices) ۲۰۲۶
- **نام‌گذاری استاندارد**:
  - `feature/اسم-فیچر`
  - `bugfix/اسم-بگ`
  - `hotfix/اسم-مشکل-فوری`
  - `release/v1.2.3`
- از **GitHub Flow** یا **Trunk-Based Development** استفاده کن (فقط یک main + برنچ‌های کوتاه).
- قبل از ایجاد برنچ جدید همیشه `git switch main && git pull` کن.
- برنچ‌های فیچر رو کوتاه نگه دار (حداکثر چند روز).
- قبل از Merge، Pull Request/Code Review بزن.

### ۸. تفاوت با سیستم‌های قدیمی (مثل SVN)
در SVN وقتی برنچ می‌زدی، واقعاً کل پوشه پروژه کپی می‌شد (چند دقیقه زمان + فضای زیاد).  
در Git فقط ۴۱ بایت فایل اشاره‌گر ساخته می‌شه. این تفاوت، دلیل اصلی «ویژگی قاتل» بودن Branching در Git هست.


